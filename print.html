<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ESP32小车开发指导书</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="preface.html">前言</a></li><li class="chapter-item expanded "><a href="chapter0/chapter_00.html">序章：环境配置与预备知识</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter0/0_1_hardware_intro.html">硬件平台介绍</a></li><li class="chapter-item expanded "><a href="chapter0/0_2_dev_env.html">开发环境准备</a></li><li class="chapter-item expanded "><a href="chapter0/0_3_prerequisites.html">前置知识引导</a></li></ol></li><li class="chapter-item expanded "><a href="chapter1/chapter_01.html">第一章：ESP32小车基本控制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter1/1_1_hardware_intro.html">硬件介绍</a></li><li class="chapter-item expanded "><a href="chapter1/1_2_io_control.html">ESP32使用I/O接口</a></li><li class="chapter-item expanded "><a href="chapter1/1_3_motor_control.html">ESP32驱动轮子</a></li><li class="chapter-item expanded "><a href="chapter1/1_4_turn_around.html">项目实践：ESP32驱动小车转向</a></li></ol></li><li class="chapter-item expanded "><a href="chapter2/chapter_02.html">第二章：ESP32小车远程控制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter2/2_1_wifi_control.html">ESP32使能WiFi</a></li><li class="chapter-item expanded "><a href="chapter2/2_2_establish_server.html">ESP32搭建网络服务</a></li><li class="chapter-item expanded "><a href="chapter2/2_3_web_control_car_advance.html">网页遥控小车前进</a></li><li class="chapter-item expanded "><a href="chapter2/2_4_web_control_car.html">项目实践：网页控制小车</a></li></ol></li><li class="chapter-item expanded "><a href="chapter3/chapter_03.html">第三章：ESP32机械抓手基本控制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter3/3_1_pwm_control.html">ESP32使用PWM</a></li><li class="chapter-item expanded "><a href="chapter3/3_2_servo_control.html">ESP32驱动舵机</a></li><li class="chapter-item expanded "><a href="chapter3/3_3_catch_tennis.html">项目实践：ESP32抓取网球</a></li></ol></li><li class="chapter-item expanded "><a href="chapter4/chapter_04.html">第四章：YOLO模型训练及识别</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter4/4_1_tennis_detect.html">网球识别</a></li><li class="chapter-item expanded "><a href="chapter4/4_2_car_detect.html">ESP32小车识别</a></li><li class="chapter-item expanded "><a href="chapter4/4_3_tennis_and_car_position_detect.html">项目实践：网球和ESP32小车位置识别</a></li></ol></li><li class="chapter-item expanded "><a href="chapter5/chapter_05.html">第五章：项目实践-边缘智能目标检测</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter5/5_1_yolo_result_to_car_cmd.html">里程碑1：根据YOLO结果返回控制小车指令</a></li><li class="chapter-item expanded "><a href="chapter5/5_2_car_cmd_turn_to_tennis.html">里程碑2：根据小车指令转向瞄准网球</a></li><li class="chapter-item expanded "><a href="chapter5/5_3_car_cmd_move_to_tennis.html">里程碑3：根据小车指令靠近网球</a></li><li class="chapter-item expanded "><a href="chapter5/5_4_car_cmd_catch_tennis.html">里程碑4：根据小车指令抓取网球</a></li></ol></li><li class="chapter-item expanded "><a href="chapter6/chapter_06.html">第六章：项目实践-使用Rust库开发ESP32小车</a></li><li class="chapter-item expanded "><a href="chapter7/chapter_07.html">第七章：项目实践-移植ArceOS Unikernel驱动小车</a></li><li class="chapter-item expanded "><a href="chapter8/chapter_08.html">第八章：项目实践-基于视觉大模型捡网球</a></li><li class="chapter-item expanded "><a href="chapter9/chapter_09.html">第九章：项目实践-通过语音交互实现捡万物</a></li><li class="chapter-item expanded "><a href="chapter10/chapter_10.html">第十章：项目实践-通过语音交互实现分类存放</a></li><li class="chapter-item expanded "><a href="chapter11/chapter_11.html">第十一章：mixly下对ESP32控制的复现</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter11/11_1_mixly_install.html">mixly安装</a></li><li class="chapter-item expanded "><a href="chapter11/11_2_mixly_intro.html">mixly界面简单介绍</a></li><li class="chapter-item expanded "><a href="chapter11/11_3_mixly_code.html">mixly下代码的复现</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ESP32小车开发指导书</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li>
<p><a href="preface.html">前言</a></p>
</li>
<li>
<p><a href="chapter0/chapter_00.html">序章：环境配置与预备知识</a></p>
<ul>
<li><a href="chapter0/0_1_hardware_intro.html">硬件平台介绍</a></li>
<li><a href="chapter0/0_2_dev_env.html">开发环境准备</a></li>
<li><a href="chapter0/0_3_prerequisites.html">前置知识引导</a></li>
</ul>
</li>
<li>
<p><a href="chapter1/chapter_01.html">第一章：ESP32小车基本控制</a></p>
<ul>
<li><a href="chapter1/1_1_hardware_intro.html">硬件介绍</a></li>
<li><a href="chapter1/1_2_io_control.html">ESP32使用I/O接口</a></li>
<li><a href="chapter1/1_3_motor_control.html">ESP32驱动轮子</a></li>
<li><a href="chapter1/1_4_turn_around.html">项目实践：ESP32驱动小车转向</a></li>
</ul>
</li>
<li>
<p><a href="chapter2/chapter_02.html">第二章：ESP32小车远程控制</a></p>
<ul>
<li><a href="chapter2/2_1_wifi_control.html">ESP32使能WiFi</a></li>
<li><a href="chapter2/2_2_establish_server.html">ESP32搭建网络服务</a></li>
<li><a href="chapter2/2_3_web_control_car_advance.html">网页遥控小车前进</a></li>
<li><a href="chapter2/2_4_web_control_car.html">项目实践：网页控制小车</a></li>
</ul>
</li>
<li>
<p><a href="chapter3/chapter_03.html">第三章：ESP32机械抓手基本控制</a></p>
<ul>
<li><a href="chapter3/3_1_pwm_control.html">ESP32使用PWM</a></li>
<li><a href="chapter3/3_2_servo_control.html">ESP32驱动舵机</a></li>
<li><a href="chapter3/3_3_catch_tennis.html">项目实践：ESP32抓取网球</a></li>
</ul>
</li>
<li>
<p><a href="chapter4/chapter_04.html">第四章：YOLO模型训练及识别</a></p>
<ul>
<li><a href="chapter4/4_1_tennis_detect.html">网球识别</a></li>
<li><a href="chapter4/4_2_car_detect.html">ESP32小车识别</a></li>
<li><a href="chapter4/4_3_tennis_and_car_position_detect.html">项目实践：网球和ESP32小车位置识别</a></li>
</ul>
</li>
<li>
<p><a href="chapter5/chapter_05.html">第五章：项目实践-边缘智能目标检测</a></p>
<ul>
<li><a href="chapter5/5_1_yolo_result_to_car_cmd.html">里程碑1：根据YOLO结果返回控制小车指令</a></li>
<li><a href="chapter5/5_2_car_cmd_turn_to_tennis.html">里程碑2：根据小车指令转向瞄准网球</a></li>
<li><a href="chapter5/5_3_car_cmd_move_to_tennis.html">里程碑3：根据小车指令靠近网球</a></li>
<li><a href="chapter5/5_4_car_cmd_catch_tennis.html">里程碑4：根据小车指令抓取网球</a></li>
</ul>
</li>
<li>
<p><a href="chapter6/chapter_06.html">第六章：项目实践-使用Rust库开发ESP32小车</a></p>
</li>
<li>
<p><a href="chapter7/chapter_07.html">第七章：项目实践-移植ArceOS Unikernel驱动小车</a></p>
</li>
<li>
<p><a href="chapter8/chapter_08.html">第八章：项目实践-基于视觉大模型捡网球</a></p>
</li>
<li>
<p><a href="chapter9/chapter_09.html">第九章：项目实践-通过语音交互实现捡万物</a></p>
</li>
<li>
<p><a href="chapter10/chapter_10.html">第十章：项目实践-通过语音交互实现分类存放</a></p>
</li>
<li>
<p><a href="chapter11/chapter_11.html">第十一章：mixly下对ESP32控制的复现</a></p>
<ul>
<li><a href="chapter11/11_1_mixly_install.html">mixly安装</a></li>
<li><a href="chapter11/11_2_mixly_intro.html">mixly界面简单介绍</a></li>
<li><a href="chapter11/11_3_mixly_code.html">mixly下代码的复现</a></li>
</ul>
</li>
</ul>
<h2 id="项目简介"><a class="header" href="#项目简介">项目简介</a></h2>
<p>本实践指南将带领您从零开始构建一个基于ESP32的智能网球捡拾小车系统。通过本项目的完整学习路径，您将掌握嵌入式开发、物联网通信、计算机视觉和智能控制等多项前沿技术。（编写中）</p>
<h2 id="学习路径"><a class="header" href="#学习路径">学习路径</a></h2>
<h3 id="基础准备"><a class="header" href="#基础准备">基础准备</a></h3>
<ul>
<li><strong>环境配置</strong>：硬件平台介绍与开发环境搭建</li>
<li><strong>预备知识</strong>：嵌入式开发基础与ESP32编程入门</li>
</ul>
<h3 id="核心技能培养"><a class="header" href="#核心技能培养">核心技能培养</a></h3>
<ol>
<li>
<p><strong>基础控制</strong></p>
<ul>
<li>ESP32 GPIO控制与电机驱动</li>
<li>实现小车基本运动控制</li>
</ul>
</li>
<li>
<p><strong>物联网应用</strong></p>
<ul>
<li>WiFi通信与网络服务搭建</li>
<li>网页远程控制实现</li>
</ul>
</li>
<li>
<p><strong>机械控制</strong></p>
<ul>
<li>PWM技术与舵机控制</li>
<li>机械抓手精准控制</li>
</ul>
</li>
<li>
<p><strong>计算机视觉</strong></p>
<ul>
<li>YOLO模型训练与部署</li>
<li>目标检测与位置识别</li>
</ul>
</li>
</ol>
<h3 id="进阶项目实践"><a class="header" href="#进阶项目实践">进阶项目实践</a></h3>
<ul>
<li><strong>边缘智能系统</strong>：实现自动网球检测与抓取全流程</li>
<li><strong>Rust开发实践</strong>：使用Rust进行嵌入式开发</li>
<li><strong>Unikernel探索</strong>：移植ArceOS驱动系统</li>
<li><strong>AI增强</strong>：视觉大模型与语音交互应用</li>
</ul>
<h2 id="技术亮点"><a class="header" href="#技术亮点">技术亮点</a></h2>
<ul>
<li>从硬件驱动到智能算法的完整开发链条</li>
<li>物联网与边缘计算的深度融合</li>
<li>传统嵌入式开发与现代AI技术的结合</li>
<li>多种编程范式与实践(Rust/Unikernel)</li>
</ul>
<h2 id="适合读者"><a class="header" href="#适合读者">适合读者</a></h2>
<ul>
<li>嵌入式开发爱好者</li>
<li>物联网应用开发者</li>
<li>计算机视觉实践者</li>
<li>希望提升完整项目开发能力的学习者</li>
</ul>
<blockquote>
<p>通过本项目的阶梯式实践，您将获得从硬件控制到智能识别算法的全栈开发能力，掌握现代嵌入式智能系统的开发方法。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="序章环境配置与预备知识"><a class="header" href="#序章环境配置与预备知识">序章：环境配置与预备知识</a></h1>
<h2 id="目录-1"><a class="header" href="#目录-1">目录</a></h2>
<ul>
<li><a href="chapter0/0_1_hardware_intro.html">* 硬件平台介绍</a>
<ul>
<li>0.1.1 开发板选型指南
<br>(a)核心硬件架构
<br>(b)外设与接口资源</li>
<li>0.1.2 电机驱动模块选型</li>
</ul>
</li>
<li><a href="chapter0/0_2_dev_env.html">* 开发环境准备</a>
<ul>
<li>0.2.1 运行环境</li>
<li>0.2.2 相关库的下载与简要介绍
<br>(a)ESPAsyncWebServer
<br>(b)LedController
<br>(c)ESP32Servo</li>
</ul>
</li>
<li><a href="chapter0/0_3_prerequisites.html">前置知识引导</a>
<ul>
<li>0.3.1 与Arduino开发相关的语法介绍
<br>(a)基础语法架构
<br>(b)相关库中核心函数的介绍</li>
<li>0.3.2 PWM基本原理</li>
</ul>
</li>
</ul>
<h2 id="预期学习成果"><a class="header" href="#预期学习成果">预期学习成果</a></h2>
<ul>
<li>硬件层面：<br>了解ESP32相关知识，完成项目所需硬件选购（开发板，小车，抓手，电池）</li>
<li>开发环境层面：<br>掌握VSCode下PlatformIO插件的基础使用方法</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="01-硬件平台介绍"><a class="header" href="#01-硬件平台介绍">0.1 硬件平台介绍</a></h1>
<h1 id="esp32开发板硬件平台详解"><a class="header" href="#esp32开发板硬件平台详解">ESP32开发板硬件平台详解</a></h1>
<p>ESP32作为一款功能强大的物联网微控制器，凭借其双核处理器、Wi-Fi/蓝牙双模通信和丰富的外设接口，成为智能小车开发的理想选择。本章将全面解析ESP32小车的硬件平台构成，包括开发板选型、电机驱动模块选择和电源系统设计，为后续开发奠定坚实基础。</p>
<h2 id="011-开发板选型指南"><a class="header" href="#011-开发板选型指南">0.1.1 开发板选型指南</a></h2>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7408e525fa523acd8aa3469a4b0f5200.png" alt="ESP32-WROOM-32E构架图" /></p>
<ul>
<li>一、核心硬件架构
<ul>
<li>1.处理器系统​​：<br>双核Xtensa® 32位LX6微处理器架构
<br>支持80MHz至240MHz动态时钟频率调节
<br>448KB ROM用于系统启动和基础功能
<br>520KB SRAM用于程序运行
<br>16KB RTC SRAM用于低功耗模式数据保持</li>
<li>2.​无线通信能力​​:<br>（1）Wi-Fi​​：
<br>支持802.11 b/g/n协议，2.4GHz频段，最高150Mbps速率
<br>支持A-MPDU和A-MSDU聚合
<br>0.4μs保护间隔优化
<br>（2）蓝牙：
<br>双模支持
<br>经典蓝牙4.2(BR/EDR)
<br>低功耗蓝牙(BLE)</li>
<li>3.存储配置​​：<br>默认集成4MB SPI Flash(可选8MB/16MB版本)
<br>部分型号额外集成2MB PSRAM(ESP32-D0WDR2-V3芯片)</li>
</ul>
</li>
<li>二、外设与接口资源
<ul>
<li>1.GPIO系统​​：<br>（1）共38个物理引脚
<br>（2）26个全功能GPIO
<br>（3）支持多种功能复用(详见后续章节)</li>
<li>2.通信接口：<br>4×SPI(支持主/从模式)
<br>2×I²C(支持主/从模式)
<br>3×UART(含1×USB-OTG)
<br>I²S音频接口
<br>CAN 2.0控制器
<br>以太网MAC接口</li>
</ul>
</li>
</ul>
<h2 id="012-电机驱动模块选型"><a class="header" href="#012-电机驱动模块选型">0.1.2 电机驱动模块选型</a></h2>
<ul>
<li>要点：
<ul>
<li>电压匹配​​：确保驱动模块支持电池电压</li>
<li>电流余量​​：电机堵转电流应小于驱动峰值电流的80%</li>
<li>控制方式​​：PWM</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="02-开发环境准备"><a class="header" href="#02-开发环境准备">0.2 开发环境准备</a></h1>
<h2 id="021-运行环境"><a class="header" href="#021-运行环境">0.2.1 运行环境</a></h2>
<p>基础运行环境可以参考如下网址 使用VSCode+PlatformIO插件搭建开发环境：
https://blog.csdn.net/msdcp/article/details/127033151
https://blog.csdn.net/jiladahe1997/article/details/108270620</p>
<h2 id="022-相关库的下载与介绍"><a class="header" href="#022-相关库的下载与介绍">0.2.2 相关库的下载与介绍</a></h2>
<ul>
<li>一、ESPAsyncWebServer
<ul>
<li>ESPAsyncWebServer是PlatformIO环境下ESP32开发中极为重要的异步Web服务器库，它为物联网设备提供了高性能的网络通信能力。</li>
<li>1.异步网络架构:
<br>非阻塞式处理​​：采用事件驱动模型，服务器在处理请求时不会阻塞其他连接，能够同时处理多个客户端请求，显著提高吞吐量;
<br>高效资源利用​​：在等待I/O操作(如文件读取、传感器数据采集)时，可以继续处理其他任务，减少CPU闲置时间;
<br>实时响应机制​​：基于回调函数的事件处理方式，确保对客户端请求的快速响应，特别适合实时数据推送场景.</li>
<li>2.协议支持能力:
<br>支持GET、POST、PUT、DELETE、PATCH、HEAD和OPTIONS等HTTP方法</li>
</ul>
</li>
<li>二、LedController
<ul>
<li>LEDController库是ESP32平台上用于控制LED和生成PWM信号的重要工具库，本项目中主要使用的是LEDController库中与PWM相关的核心函数（详见后续语法介绍）。</li>
</ul>
</li>
<li>三、ESP32Servo
<ul>
<li>ESP32Servo库是专为ESP32系列微控制器设计的舵机控制库，它提供了简单易用的接口来控制标准舵机。具体包括基础控制功能，对多个舵机独立管理控制；运动控制功能，控制舵机角度、平滑运动等；状态查询功能，获取当前位置以及PWM通道查询等。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="03-前置知识引导"><a class="header" href="#03-前置知识引导">0.3 前置知识引导</a></h1>
<h2 id="与arduino开发相关的语法介绍"><a class="header" href="#与arduino开发相关的语法介绍">与Arduino开发相关的语法介绍</a></h2>
<ul>
<li>一、基础语法架构
<br><code>void setup() { // 初始化代码，只执行一次}</code>
<br><code>void loop() { // 主循环代码，重复执行}</code>
<br><code>Serial.begin(115200); // 初始化串口，波特率115200</code>
<br><code>Serial.print()    // 发送数据到串口</code></li>
<li>二、相关库中核心函数的介绍
<ul>
<li><strong>LedController</strong>
<br>(1)<strong>ledcSetup() - PWM通道初始化</strong>
<br><code>double ledcSetup(uint8_t chan, double freq, uint8_t bit_num)</code>
<br>i.<strong>功能</strong>​​：配置指定LEDC通道的PWM信号参数
​​  <br>ii.<strong>参数</strong>​​：
<br>chan：通道号(0-15，取决于ESP32型号)
<br>freq：PWM频率(Hz)
<br>bit_num：占空比分辨率(1-16位)
​​  <br>返回值​​：实际设置的频率值
​​  <br>iii.<strong>说明</strong>​​：必须先调用此函数初始化通道才能使用其他PWM功能
<br>(2)<strong>ledcAttachPin() - 引脚绑定</strong>
<br><code>void ledcAttachPin(uint8_t pin, uint8_t chan)</code>
<br>i.<strong>功能</strong>​​：将GPIO引脚绑定到指定的PWM通道
​​  <br>ii.<strong>参数</strong>​​：
<br>pin：GPIO引脚号
<br>chan：已初始化的PWM通道号
​​  <br>iii.<strong>说明</strong>​​：一个通道可绑定多个引脚，实现同步控制
<br>(3)<strong>ledcWrite() - 占空比设置</strong>
<br><code>void ledcWrite(uint8_t chan, uint32_t duty)</code>
<br>i.<strong>功能</strong>​​：设置指定通道的PWM占空比
​  <br>ii.<strong>​参数</strong>​​：
<br>chan：PWM通道号
<br>duty：占空比值(范围由分辨率决定)
​​  <br>iii.<strong>说明</strong>​​：这是最核心的PWM输出函数，用于实时调整输出强度</li>
</ul>
</li>
</ul>
<h2 id="pwm原理与占空比计算"><a class="header" href="#pwm原理与占空比计算">PWM原理与占空比计算</a></h2>
<ul>
<li>PWM基本原理
<ul>
<li>1.<strong>核心概念</strong>
<br><strong>脉冲信号</strong>​​：由高电平和低电平交替组成的方波信号
​​  <br><strong>周期</strong>(T)​：一个完整PWM波形的时间长度（单位：秒）
​​  <br><strong>频率</strong>(f)​​：单位时间内周期数，f=1/T（单位：Hz）
​​  <br><strong>脉宽</strong>(高电平时间)​​：一个周期内信号保持高电平的时间
​​  <br><strong>占空比</strong>(D)：高电平时间与周期的比值，D = (高电平时间/T) × 100%</li>
<li>2.<strong>工作原理</strong>
<br><strong>PWM基于​​面积等效原理</strong>​​：冲量（脉冲面积）相等而形状不同的窄脉冲加在具有惯性的环节上时，其效果基本相同。
<br>通过改变占空比来调节平均输出电压：
<br>占空比越大 → 平均电压越高
<br>占空比越小 → 平均电压越低</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一章esp32小车基本控制"><a class="header" href="#第一章esp32小车基本控制">第一章：ESP32小车基本控制</a></h1>
<h2 id="目录-2"><a class="header" href="#目录-2">目录</a></h2>
<ul>
<li><a href="chapter1/1_1_hardware_intro.html">硬件介绍</a>
<ul>
<li>1.1.1 ESP32核心引脚</li>
<li>1.1.2 ESP32开发板的基本功能</li>
</ul>
</li>
<li><a href="chapter1/1_2_io_control.html">ESP32使用I/O接口</a>
<ul>
<li>1.2.1 数字I/O的不同工作模式介绍</li>
<li>1.2.2 Arduino框架</li>
</ul>
</li>
<li><a href="chapter1/1_3_motor_control.html">ESP32驱动轮子</a>
<ul>
<li>1.3.1 硬件连接
<br>(a)引脚连接参考</li>
<li>1.3.1 相关函数的编写
<br>(a)电机控制函数</li>
<li>1.3.2 串口连接与烧录
<br>(a)调试方法
<br>(b)常见问题解决</li>
<li>1.3.3 预期实现成果展示</li>
</ul>
</li>
<li><a href="chapter1/1_4_turn_around.html">项目实践：ESP32驱动小车转向</a>
<ul>
<li>1.4.1 提示</li>
<li>1.4.2 预期实现成果</li>
</ul>
</li>
</ul>
<h2 id="预期学习成果-1"><a class="header" href="#预期学习成果-1">预期学习成果</a></h2>
<ul>
<li>能够依照实例编写出相关控制小车运动的函数</li>
<li>小车能够实现前进、后退、转向、刹车、休眠等多种运动效果</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="硬件介绍"><a class="header" href="#硬件介绍">硬件介绍</a></h1>
<h2 id="esp32核心引脚"><a class="header" href="#esp32核心引脚">ESP32核心引脚</a></h2>
<p><img src="chapter1/../resource/img/ESP32-WROOM-32E.png" alt="ESP32-WROOM-32E引脚图" /></p>
<ul>
<li>
<p>一、电源管理引脚</p>
<ul>
<li>
<p>1.VCC​​：3.3V电源输入端子，为整个芯片提供工作电压</p>
</li>
<li>
<p>2.​GND​​：接地端子，与电源负极相连</p>
</li>
<li>
<p>​3.​EN​​：使能控制管脚，高电平激活芯片工作状态，低电平触发重启</p>
</li>
</ul>
</li>
<li>
<p>二、<strong>通信接口引脚</strong></p>
<ul>
<li>
<p>1.<strong>UART接口</strong>
<br>TXD/RXD​​：串行数据发送/接收管脚
​  <br>​RTS/CTS​​：硬件流控信号线，用于控制传输速率</p>
</li>
<li>
<p>2.<strong>I2C接口</strong>
<br>SDA/SCL​​：两线式同步串行总线的数据线和时钟线</p>
</li>
</ul>
</li>
<li>
<p>三、特殊功能引脚</p>
<ul>
<li>
<p>1.<strong>ADC/DAC引脚</strong>
<br>(1)ADC输入​​：18个12位ADC通道(实际可用6-8个)
<br>ADC1：GPIO1-8(部分不可用)
<br>ADC2：GPIO9-17(使用Wi-Fi时不可用)
<br>(2)DAC输出​​：GPIO25(DAC1)、GPIO26(DAC2)，8位分辨率</p>
</li>
<li>
<p>2.<strong>PWM输出</strong>
<br>支持16个PWM通道，几乎所有输出引脚都可配置为PWM</p>
</li>
</ul>
</li>
</ul>
<h2 id="esp32开发板的基本功能"><a class="header" href="#esp32开发板的基本功能">ESP32开发板的基本功能</a></h2>
<ul>
<li>
<p>一、核心处理能力</p>
<ul>
<li>双核处理器：
<br>(1)搭载Xtensa® LX6双核32位MCU，主频高达240MHz，支持并行任务处理（如一个核心处理无线协议栈，另一个运行用户程序）。
<br>(2)支持硬件浮点运算单元（FPU），适合复杂算法（如语音识别、机器学习）</li>
</ul>
</li>
<li>
<p>二、无线通信功能</p>
<ul>
<li>WiFi连接:
<br>支持802.11 b/g/n协议（2.4GHz），传输速率达150Mbps，提供STA（客户端）、AP（热点）或混合模式</li>
</ul>
</li>
<li>
<p>三、外设接口</p>
<ul>
<li>GPIO与PWM:
<br>最多34个可编程GPIO（部分型号如ESP32-P4达55个），支持输入/输出、中断和PWM控制（如LED调光、舵机驱动）</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esp32使用io接口"><a class="header" href="#esp32使用io接口">ESP32使用I/O接口</a></h1>
<h2 id="数字io的不同工作模式介绍"><a class="header" href="#数字io的不同工作模式介绍">数字I/O的不同工作模式介绍</a></h2>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b5e5d7d537c60a57956b11f2739ec9c2.png" alt="ESP32管脚图" /></p>
<ul>
<li>
<p>一、基本输入输出模式</p>
<ul>
<li>
<p>1.数字输入模式(INPUT)
<br>用于读取外部数字信号状态(高/低电平)</p>
</li>
<li>
<p>2.数字输出模式(OUTPUT)
<br>控制引脚输出高/低电平</p>
</li>
</ul>
</li>
<li>
<p>二、带内部电阻的输入模式</p>
<ul>
<li>
<p>1.<strong>上拉输入模式(INPUT_PULLUP)</strong>
<br><strong>(1)功能</strong>：
<br>启用内部上拉电阻(约45kΩ)的输入模式
<br><strong>(2)特点</strong>：
<br>引脚悬空时默认读取为高电平
<br>适合连接接地式开关/按键
<br>可节省外部上拉电阻</p>
</li>
<li>
<p>2.<strong>下拉输入模式(INPUT_PULLDOWN)</strong>
<br><strong>(1)功能</strong>​​：
<br>启用内部下拉电阻(约45kΩ)的输入模式
<br><strong>(2)特点</strong>​​：
<br>引脚悬空时默认读取为低电平
<br>适合连接接电源式开关/按键
<br>可节省外部下拉电阻</p>
</li>
</ul>
</li>
</ul>
<h2 id="arduino框架"><a class="header" href="#arduino框架">Arduino框架</a></h2>
<ul>
<li>
<p>一、必要头函数/库</p>
<ul>
<li>
<p>1.Arduino
<br>核心库，包括GPIO基础函数</p>
</li>
<li>
<p>2.LedConctroller
<br>将控制GPIO的基础函数替换，如下</p>
</li>
</ul>
<pre><code>//Aruino
pinMode(pin, mode);  // 配置引脚为输入或输出模式
digitalWrite(pin, value);  // 设置输出电平（HIGH/LOW）
</code></pre>
<pre><code>//LedController
//介绍详见上一章
ledcSetup(uint8_t chan, double freq, uint8_t bit_num);
ledcAttachPin(uint8_t pin, uint8_t chan);
edcWrite(uint8_t chan, uint32_t duty);
</code></pre>
</li>
<li>
<p>二、代码样例</p>
</li>
</ul>
<pre><code>#include &lt;Arduino.h&gt;
void Motor_Setup(int motorID, int pin1,
                 int pin2) {  // 电机初始化 ID=1~4 定义四组电机
  ledcSetup(motorID * 2 - 2, freq, resolution_bits);
  ledcAttachPin(pin1, motorID * 2 - 2);
  ledcSetup(motorID * 2 - 1, freq, resolution_bits);
  ledcAttachPin(pin2, motorID * 2 - 1);
}
void setup() {
  delay(500);
  Serial.begin(115200);
  
  Motor_Setup(1, 27, 13); // 设电机组标号和对应的引脚
  Motor_Setup(2, 4, 2);
  Motor_Setup(3, 17, 12);
  Motor_Setup(4, 15, 14);
}


void loop() {
  delay(1000);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esp32驱动轮子"><a class="header" href="#esp32驱动轮子">ESP32驱动轮子</a></h1>
<h2 id="硬件的连接"><a class="header" href="#硬件的连接">硬件的连接</a></h2>
<ul>
<li>
<p>引脚连接参考</p>
<ul>
<li>电机1 PWM: GPIO27
<br>电机1 DIR: GPIO13
<br>电机2 PWM: GPIO4
<br>电机2 DIR: GPIO2
<br>电机3 PWM: GPIO17
<br>电机3 DIR: GPIO12
<br>电机4 PWM: GPIO15
<br>电机4 DIR: GPIO14</li>
</ul>
</li>
</ul>
<h2 id="相关函数的编写"><a class="header" href="#相关函数的编写">相关函数的编写</a></h2>
<ul>
<li>
<p>电机控制函数</p>
<ul>
<li>
<p>速度控制函数
<br>依照ledcWrite()函数相关功能进行编写</p>
</li>
<li>
<p>代码样例</p>
</li>
</ul>
<pre><code>void Motor_Speed(int motorID, int speed) 
{  // 电机速度设置 // ID=1~4,speed=-255~255
if (speed == 0) {
  ledcWrite(motorID * 2 - 2, 0);
  ledcWrite(motorID * 2 - 1, 0);
} else if (speed &gt; 0) {
  ledcWrite(motorID * 2 - 2, speed);
  ledcWrite(motorID * 2 - 1, 0);
} else {
  ledcWrite(motorID * 2 - 2, 0);
  ledcWrite(motorID * 2 - 1, -speed);
}
}
//其中motorID * 2 - 2对应的是PWM通道，设置为从0开始
</code></pre>
</li>
</ul>
<h2 id="串口调试与烧录"><a class="header" href="#串口调试与烧录">串口调试与烧录</a></h2>
<ul>
<li>
<p>一、调试方法</p>
<ul>
<li>
<p>PlatformIO提供了方便的串口监视器：
<br>点击底部状态栏&quot;插头&quot;图标
<br>或命令面板输入&quot;PlatformIO: Serial Monitor&quot;
<br>快捷键Ctrl+T Ctrl+X退出监视器</p>
</li>
<li>
<p>可以在代码中添加Serial.println()函数增加调试信息</p>
</li>
</ul>
</li>
<li>
<p>二、常见问题解决</p>
<ul>
<li>
<p>1.<strong>上传失败</strong>:
<br>检查USB连接</p>
</li>
<li>
<p>2.<strong>库冲突</strong>:
<br>去除非必要的库，避免引起冲突</p>
</li>
<li>
<p>3.<strong>电机响应异常</strong>：
<br>检查电源是否充足
<br>检查PWM频率和分辨率</p>
</li>
</ul>
</li>
</ul>
<h2 id="预期实现成果展示"><a class="header" href="#预期实现成果展示">预期实现成果展示</a></h2>
<video width="600" height="600" controls>
  <source src="../resource/img/up_motorcontrol.mp4" type="video/mp4">
</video><div style="break-before: page; page-break-before: always;"></div><h1 id="项目实践esp32驱动小车转向"><a class="header" href="#项目实践esp32驱动小车转向">项目实践：ESP32驱动小车转向</a></h1>
<h2 id="提示"><a class="header" href="#提示">提示</a></h2>
<ul>
<li>差速转向</li>
<li>刹车与休眠的区别</li>
</ul>
<h2 id="预期实现成果"><a class="header" href="#预期实现成果">预期实现成果</a></h2>
<video width="600" height="600" controls>
  <source src="../resource/img/turn.mp4" type="video/mp4">
</video><div style="break-before: page; page-break-before: always;"></div><h1 id="第二章esp32小车远程控制"><a class="header" href="#第二章esp32小车远程控制">第二章：ESP32小车远程控制</a></h1>
<h2 id="目录-3"><a class="header" href="#目录-3">目录</a></h2>
<ul>
<li><a href="chapter2/2_1_wifi_control.html">ESP32使能WiFi</a>
<ul>
<li>2.1.1 ESP32的WiFi板块函数的介绍</li>
<li>2.1.2 WiFi板块基本代码架构</li>
</ul>
</li>
<li><a href="chapter2/2_2_establish_server.html">ESP32搭建网络服务</a>
<ul>
<li>2.2.1 网页搭建简单介绍</li>
<li>2.2.2 网页搭建基本代码架构</li>
<li>2.2.3 预期实现成果</li>
</ul>
</li>
<li><a href="chapter2/2_3_web_control_car_advance.html">网页遥控小车前进</a>
<ul>
<li>2.3.1 控制运动板块与WiFi、网页搭建等板块的结合</li>
<li>2.3.2 预期实现成果</li>
</ul>
</li>
<li><a href="chapter2/2_4_web_control_car.html">项目实践：网页控制小车</a></li>
</ul>
<ul>
<li>2.4.1 提示</li>
<li>2.4.2 预期实现成果</li>
</ul>
<h2 id="预期学习成果-2"><a class="header" href="#预期学习成果-2">预期学习成果</a></h2>
<ul>
<li>ESP32能够连接WiFi并返回一些内容</li>
<li>能够搭建出包含控制小车运动按钮的简单网页</li>
<li>网页可以遥控小车实现多种运动效果，包括前进、后退、左转向、右转向、刹车等。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esp32使能wifi"><a class="header" href="#esp32使能wifi">ESP32使能WiFi</a></h1>
<h2 id="esp32的wifi板块函数的介绍"><a class="header" href="#esp32的wifi板块函数的介绍">ESP32的WiFi板块函数的介绍</a></h2>
<ul>
<li>
<p>基础WiFi连接函数</p>
<ul>
<li>
<p>1.WiFi初始化与连接
<br>(1)<strong>WiFi.begin()​​ - 用于连接到指定的WiFi网络</strong>
<br><code>WiFi.begin(ssid, password);  // 连接到指定SSID和密码的WiFi网络</code>
<br>(2)<strong>WiFi.status()​​ - 返回当前WiFi连接状态</strong>
<br><code>wl_status_t status = WiFi.status();</code>
<br>常见返回值：
<br>WL_CONNECTED: 已连接(值为3)
<br>WL_NO_SSID_AVAIL: 未找到指定网络(值为1)
<br>WL_CONNECT_FAILED: 连接失败(值为4)
<br>WL_IDLE_STATUS: WiFi处于空闲状态(值为0)
<br>WL_DISCONNECTED: 未连接(值为6)</p>
</li>
<li>
<p>2.网络信息获取
<br><strong>WiFi.localIP()​​ - 获取ESP32在局域网中的IP地址</strong>
<br><code>IPAddress ip = WiFi.localIP();</code>
<br><code>Serial.println(ip);  // 打印IP地址如&quot;192.168.1.100&quot;</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="wifi板块基本代码架构"><a class="header" href="#wifi板块基本代码架构">WiFi板块基本代码架构</a></h2>
<ul>
<li>
<p>一、初始化</p>
<ul>
<li>配置模块的工作模式
<br><code>WiFi.mode(WIFI_STA);</code></li>
</ul>
</li>
<li>
<p>二、准备步骤</p>
<ul>
<li>指定需要连接的WiFi
<br><code>WiFi.begin(ssid, password);</code></li>
</ul>
</li>
<li>
<p>三、连接WiFi+打印ip地址</p>
<pre><code>while (WiFi.status() != WL_CONNECTED) {
  delay(500);
  Serial.print(&quot;.&quot;);
}
Serial.println(&quot;\nIP地址: &quot; + WiFi.localIP().toString());
</code></pre>
</li>
<li>
<p>四、代码示例</p>
</li>
</ul>
<pre><code>void Setup(){
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(&quot;.&quot;);
  }
  Serial.println(&quot;\nIP地址: &quot; + WiFi.localIP().toString());
}
void loop() {
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esp32搭建网络服务"><a class="header" href="#esp32搭建网络服务">ESP32搭建网络服务</a></h1>
<h2 id="网页搭建简单介绍"><a class="header" href="#网页搭建简单介绍">网页搭建简单介绍</a></h2>
<ul>
<li>ESP32可以搭建简单的Web服务器，通过浏览器访问ESP32的IP地址即可获取响应</li>
</ul>
<h2 id="网页搭建基本代码架构"><a class="header" href="#网页搭建基本代码架构">网页搭建基本代码架构</a></h2>
<ul>
<li>
<p>必要头函数
<br><code>#include &lt;ESPAsyncWebServer.h&gt;</code></p>
</li>
<li>
<p>HTML页面嵌入方式
<br>直接字符串嵌入​​：适合简单页面
<br><code>const char index_html[]PROGMEM=R&quot;rawliteral(&lt;html&gt;&lt;body&gt;&lt;h1&gt;ESP32 Control Panel&lt;/h1&gt;&lt;button onclick=&quot;fetch('/led?state=1')&quot;&gt;Turn ON&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;)rawliteral&quot;;</code></p>
</li>
<li>
<p>代码样例</p>
</li>
</ul>
<pre><code>const char* webpage = &quot;&lt;!DOCTYPE html&gt;&lt;html lang=\&quot;zh-CN\&quot;&gt;&lt;head&gt;&lt;meta charset=\&quot;UTF-8\&quot;&gt;&lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width,initial-scale=1.0\&quot;&gt;&lt;title&gt;小车控制面板&lt;/title&gt;&lt;style&gt;body{font-family:Arial,sans-serif;background:#f0f2f5;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;margin:0;padding:20px;}.container{background:#fff;border-radius:15px;box-shadow:0 10px 25px rgba(0,0,0,0.1);padding:30px;width:100%;max-width:400px;text-align:center;}h1{color:#333;margin-bottom:30px;}.control-section{margin-bottom:30px;}.direction-pad{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:20px;}.btn{background:#4a6fa5;color:#fff;border:none;border-radius:8px;padding:15px;font-size:16px;cursor:pointer;transition:all 0.3s;box-shadow:0 4px 6px rgba(0,0,0,0.1);}.btn:hover{background:#3a5a80;transform:translateY(-2px);box-shadow:0 6px 8px rgba(0,0,0,0.15);}.btn:active{transform:translateY(0);box-shadow:0 2px 4px rgba(0,0,0,0.1);}.btn-up{grid-column:2;}.btn-left{grid-column:1;grid-row:2;}.btn-stop{grid-column:2;grid-row:2;background:#d9534f;}.btn-right{grid-column:3;grid-row:2;}.btn-down{grid-column:2;grid-row:3;}.arm-control{display:flex;justify-content:space-around;margin-top:20px;}.btn-grab{background:#5cb85c;}.btn-release{background:#d9534f;}.btn-reset{background:#f0ad4e;}.btn-grab:hover{background:#4cae4c;}.btn-release:hover{background:#c9302c;}.btn-reset:hover{background:#ec971f;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\&quot;container\&quot;&gt;&lt;h1&gt;小车控制面板&lt;/h1&gt;&lt;div class=\&quot;control-section\&quot;&gt;&lt;h2&gt;方向控制&lt;/h2&gt;&lt;div class=\&quot;direction-pad\&quot;&gt;&lt;button class=\&quot;btn btn-up\&quot; onclick=\&quot;sendCommand('up')\&quot;&gt;↑&lt;/button&gt;&lt;button class=\&quot;btn btn-left\&quot; onclick=\&quot;sendCommand('left')\&quot;&gt;←&lt;/button&gt;&lt;button class=\&quot;btn btn-stop\&quot; onclick=\&quot;sendCommand('stop')\&quot;&gt;STOP&lt;/button&gt;&lt;button class=\&quot;btn btn-right\&quot; onclick=\&quot;sendCommand('right')\&quot;&gt;→&lt;/button&gt;&lt;button class=\&quot;btn btn-down\&quot; onclick=\&quot;sendCommand('down')\&quot;&gt;↓&lt;/button&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\&quot;control-section\&quot;&gt;&lt;h2&gt;机械臂控制&lt;/h2&gt;&lt;div class=\&quot;arm-control\&quot;&gt;&lt;button class=\&quot;btn btn-grab\&quot; onclick=\&quot;sendCommand('grab')\&quot;&gt;抓取&lt;/button&gt;&lt;button class=\&quot;btn btn-reset\&quot; onclick=\&quot;sendCommand('reset')\&quot;&gt;复原&lt;/button&gt;&lt;button class=\&quot;btn btn-release\&quot; onclick=\&quot;sendCommand('release')\&quot;&gt;放下&lt;/button&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;function sendCommand(a){fetch('/control?action='+a).then(r=&gt;{if(!r.ok)console.error('请求失败')}).catch(e=&gt;console.error('请求错误:',e));}document.addEventListener('keydown',e=&gt;{const k={ArrowUp:'up',ArrowLeft:'left',ArrowRight:'right',ArrowDown:'down',g:'grab',r:'release',s:'stop',t:'reset'}[e.key];if(k)sendCommand(k);});&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
</code></pre>
<ul>
<li>
<p>代码解析</p>
<ul>
<li>
<p>1.<strong>基本结构​​</strong>
<br>这是一个完整的HTML5页面，包含&lt;!DOCTYPE&gt;声明、中文字符集(UTF-8)和响应式视口设置。
<br><strong>页面分为两个控制区</strong>：
​  <br>(1)​方向控制​​：通过5个按钮（上、下、左、右、停止）发送指令。
​<br>(2)​机械臂控制​​：通过3个按钮（抓取、复原、放下）发送指令。</p>
</li>
<li>
<p>2.<strong>核心交互逻辑​​</strong>
<br>(1)按钮通过onclick事件调用sendCommand()函数，发送HTTP GET请求到ESP32的/control端点，例如：<code>fetch('/control?action=up')  // 发送&quot;up&quot;指令</code>
<br>(2)支持键盘快捷键（方向键对应方向控制，g/r/s/t对应机械臂操作）。</p>
</li>
<li>
<p>3.<strong>​样式设计</strong>​​
<br>使用CSS Flex/Grid布局实现响应式按钮排列。
<br>按钮有悬停/点击动画效果，不同功能按钮通过颜色区分（如红色表示停止）。</p>
</li>
<li>
<p>4.<strong>优化</strong>
<br><strong>​​换行符问题</strong>​​:
<br>原始代码中包含换行符（\n）和缩进，会增加字符串长度，可能超出ESP32的存储限制（尤其是Flash或NVS分区容量）。
<br>换行符在不同系统中可能为\n（Unix）或\r\n（Windows），需统一处理。</p>
</li>
</ul>
</li>
</ul>
<h2 id="预期实现成果-1"><a class="header" href="#预期实现成果-1">预期实现成果</a></h2>
<p><img src="chapter2/../resource/img/2.2server.png" alt="webpage" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网页遥控小车前进"><a class="header" href="#网页遥控小车前进">网页遥控小车前进</a></h1>
<h2 id="控制运动板块与wifi网页搭建等板块的结合"><a class="header" href="#控制运动板块与wifi网页搭建等板块的结合">控制运动板块与WiFi、网页搭建等板块的结合</a></h2>
<ul>
<li>
<p>使用AsyncWebServer中on函数接收网页相关指令</p>
</li>
<li>
<p>这里使用的是GET请求</p>
<pre><code>server.on(&quot;/led&quot;, HTTP_GET, [](AsyncWebServerRequest *request){
String state = request-&gt;getParam(&quot;state&quot;)-&gt;value();
digitalWrite(LED_PIN, state.toInt());
request-&gt;send(200);});

</code></pre>
</li>
<li>
<p>通过以下方法对应控制运动相关函数：
<br><code>request-&gt;getParam(&quot;state&quot;)-&gt;value()</code></p>
</li>
<li>
<p>代码样例</p>
</li>
</ul>
<pre><code>const char* webpage = &quot;&quot;;//自己编写的网页
AsyncWebServer server(80);
const char* ssid = &quot;Tsinghua-Dongsheng&quot;;
const char* password = &quot;&quot;;
void notFound(AsyncWebServerRequest *request) {
    request-&gt;send(404, &quot;text/plain&quot;, &quot;Not found&quot;);
}
</code></pre>
<h2 id="预期实现成果-2"><a class="header" href="#预期实现成果-2">预期实现成果</a></h2>
<video width="600" height="600" controls>
  <source src="../resource/img/up_server.mp4" type="video/mp4">
</video><div style="break-before: page; page-break-before: always;"></div><h1 id="项目实践网页控制小车"><a class="header" href="#项目实践网页控制小车">项目实践：网页控制小车</a></h1>
<h2 id="提示-1"><a class="header" href="#提示-1">提示</a></h2>
<ul>
<li>完善网页中的按钮，使每个运动状态都有所对应</li>
<li>根据网页遥控小车前进照猫画虎</li>
</ul>
<h2 id="预期实现成果-3"><a class="header" href="#预期实现成果-3">预期实现成果</a></h2>
<video width="600" height="600" controls>
  <source src="../resource/img/server.mp4" type="video/mp4">
</video><div style="break-before: page; page-break-before: always;"></div><h1 id="第三章esp32机械抓手基本控制"><a class="header" href="#第三章esp32机械抓手基本控制">第三章：ESP32机械抓手基本控制</a></h1>
<h2 id="目录-4"><a class="header" href="#目录-4">目录</a></h2>
<ul>
<li><a href="chapter3/chapter3/3_1_pwm_control.html">ESP32使用PWM</a></li>
</ul>
<ul>
<li>3.1.1 使用PWM控制舵机的语法基本框架
<br>(a)初始化与绑定通道
<br>(b)编写控制舵机角度函数
<br>(c)对多个电机进行控制，实现对抓手运动状态控制
<br>(d)代码样例</li>
</ul>
<ul>
<li><a href="chapter3/chapter3/3_2_servo_control.html">ESP32驱动舵机</a></li>
</ul>
<ul>
<li>3.2.1 舵机信号脉宽映射与角度控制
<br>(a)舵机控制原理
<br>(b)角度到脉宽的转换公式
<br>(c)代码样例</li>
</ul>
<ul>
<li><a href="chapter3/chapter3/3_3_catch_tennis.html">项目实践：ESP32抓取网球</a></li>
</ul>
<h2 id="预期学习成果-3"><a class="header" href="#预期学习成果-3">预期学习成果</a></h2>
<ul>
<li>能够控制多个舵机转动</li>
<li>抓手能呈现抓、放等预计姿态</li>
<li>网页端可以遥控抓手进行抓球</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esp32使用pwm"><a class="header" href="#esp32使用pwm">ESP32使用PWM</a></h1>
<h2 id="使用pwm控制舵机的语法基本框架"><a class="header" href="#使用pwm控制舵机的语法基本框架">使用PWM控制舵机的语法基本框架</a></h2>
<ul>
<li>
<p>一、初始化与绑定通道</p>
<ul>
<li>主要使用函数
<br><code>ledcSetup(PWM_CHANNEL, PWM_FREQ, PWM_RESOLUTION);</code>
<br><code>ledcAttachPin(SERVO_PIN, PWM_CHANNEL);</code></li>
</ul>
</li>
<li>
<p>二、编写控制舵机角度函数</p>
<ul>
<li>
<p>利用角度、脉宽、分辨率之间的关系编写</p>
</li>
<li>
<p>使用<code>ledcWrite(PWM_CHANNEL, duty);</code>
<br>进行输出</p>
</li>
</ul>
</li>
<li>
<p>三、对多个电机进行控制，实现对抓手运动状态控制</p>
<ul>
<li>根据舵机实际情况，编写能实现抓手初始状态、抓物状态、缩回状态、释放状态等的各种函数</li>
</ul>
</li>
<li>
<p>四、代码样例</p>
</li>
</ul>
<pre><code>void Servo_Setup(){
  ledcSetup(PWM_CHANNEL_1, PWM_FREQ, PWM_RESOLUTION);
  ledcAttachPin(SERVO_PIN_1, PWM_CHANNEL_1);
  ledcSetup(PWM_CHANNEL_2, PWM_FREQ, PWM_RESOLUTION);
  ledcAttachPin(SERVO_PIN_2, PWM_CHANNEL_2);
  ledcSetup(PWM_CHANNEL_3, PWM_FREQ, PWM_RESOLUTION);
  ledcAttachPin(SERVO_PIN_3, PWM_CHANNEL_3);
}

void setAngle(int servoNum, int angle) {
  angle = constrain(angle, 0, 180); // 限制角度范围
  //duty,angle与pulseWidth的关系见后一节
  ledcWrite(servoNum, duty);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esp32驱动舵机"><a class="header" href="#esp32驱动舵机">ESP32驱动舵机</a></h1>
<h2 id="舵机信号脉宽映射与角度控制"><a class="header" href="#舵机信号脉宽映射与角度控制">舵机信号脉宽映射与角度控制</a></h2>
<ul>
<li>一、舵机控制原理</li>
</ul>
<p>以下是所使用舵机的PWM脉宽范围
<img src="https://i-blog.csdnimg.cn/blog_migrate/3839b394f9183896344d5e36e68762a5.png#pic_center" alt="PWM脉宽范围" title="PWM脉宽范围" /></p>
<ul>
<li>二、角度、分辨率、脉宽的转换公式</li>
</ul>
<ul>
<li>
<p>1.分辨率与脉宽的转换公式：
<br><code>duty = (pulseWidth / 20000) × (2^duty_max - 1)</code>
<br>例如，分辨率为16位，0.5ms脉冲宽度对应的duty值即为(500/20000)×65535=1638</p>
</li>
<li>
<p>2.角度和脉宽的转换公式：
<br><code>angle = (pulseWidth_us - 500) × (180 / (2500 - 500))</code></p>
</li>
<li>
<p>由上述两个公式即可推导出角度和分辨率之间的关系</p>
</li>
</ul>
<ul>
<li>三、代码样例</li>
</ul>
<pre><code>void setAngle(int servoNum, int angle) {
  angle = constrain(angle, 0, 180); // 限制角度范围
  float pulseWidth = 500 + angle * (2000.0 / 180.0); // 精确到11.111μs/°// 绝对值映射
  uint32_t duty = (uint32_t)((pulseWidth / 20000.0) * 65535 + 0.5); // 四舍五入
  ledcWrite(servoNum, duty);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目实践esp32抓取网球"><a class="header" href="#项目实践esp32抓取网球">项目实践：ESP32抓取网球</a></h1>
<h2 id="提示-2"><a class="header" href="#提示-2">提示</a></h2>
<ul>
<li>根据实际抓手各部分组装方式调整舵机角度</li>
<li>在角度函数中增加while循环和delay()控制抓手速度</li>
</ul>
<h2 id="预期实现成果-4"><a class="header" href="#预期实现成果-4">预期实现成果</a></h2>
<video width="600" height="600" controls>
  <source src="../resource/img/catch_tennis.mp4" type="video/mp4">
</video><div style="break-before: page; page-break-before: always;"></div><h1 id="第四章yolo模型训练及识别"><a class="header" href="#第四章yolo模型训练及识别">第四章：YOLO模型训练及识别</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网球识别"><a class="header" href="#网球识别">网球识别</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esp32小车识别"><a class="header" href="#esp32小车识别">ESP32小车识别</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目实践网球和esp32小车位置识别"><a class="header" href="#项目实践网球和esp32小车位置识别">项目实践：网球和ESP32小车位置识别</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第五章项目实践-边缘智能目标检测"><a class="header" href="#第五章项目实践-边缘智能目标检测">第五章：项目实践-边缘智能目标检测</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="里程碑1根据yolo结果返回控制小车指令"><a class="header" href="#里程碑1根据yolo结果返回控制小车指令">里程碑1：根据YOLO结果返回控制小车指令</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="里程碑2根据小车指令转向瞄准网球"><a class="header" href="#里程碑2根据小车指令转向瞄准网球">里程碑2：根据小车指令转向瞄准网球</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="里程碑3根据小车指令靠近网球"><a class="header" href="#里程碑3根据小车指令靠近网球">里程碑3：根据小车指令靠近网球</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="里程碑4根据小车指令抓取网球"><a class="header" href="#里程碑4根据小车指令抓取网球">里程碑4：根据小车指令抓取网球</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第六章项目实践-使用rust库开发esp32小车"><a class="header" href="#第六章项目实践-使用rust库开发esp32小车">第六章：项目实践-使用Rust库开发ESP32小车</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第七章项目实践-移植arceos-unikernel驱动小车"><a class="header" href="#第七章项目实践-移植arceos-unikernel驱动小车">第七章：项目实践-移植ArceOS Unikernel驱动小车</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第八章项目实践-基于视觉大模型捡网球"><a class="header" href="#第八章项目实践-基于视觉大模型捡网球">第八章：项目实践-基于视觉大模型捡网球</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第九章项目实践-通过语音交互实现捡万物"><a class="header" href="#第九章项目实践-通过语音交互实现捡万物">第九章：项目实践-通过语音交互实现捡万物</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第十章项目实践-通过语音交互实现分类存放"><a class="header" href="#第十章项目实践-通过语音交互实现分类存放">第十章：项目实践-通过语音交互实现分类存放</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第十一章mixly下对esp32控制的复现"><a class="header" href="#第十一章mixly下对esp32控制的复现">第十一章：mixly下对ESP32控制的复现</a></h1>
<h2 id="目录-5"><a class="header" href="#目录-5">目录</a></h2>
<ul>
<li>
<p><a href="chapter11/11_1_mixly_install.html">Mixly安装与使用</a></p>
<ul>
<li>
<p>11.1.1 Mixly安装教程</p>
</li>
<li>
<p>11.1.2 Mixly使用方法</p>
</li>
</ul>
</li>
<li>
<p><a href="chapter11/11_2_mixly_intro.html">Mixly界面简单介绍</a></p>
<ul>
<li>
<p>11.2.1 Mixly界面不同分区简要介绍</p>
</li>
<li>
<p>11.2.2 基础模块区和库模块区使用方法</p>
</li>
</ul>
</li>
<li>
<p><a href="chapter11/11_3_mixly_code.html">项目实践：Mixly下代码的复现</a></p>
<ul>
<li>
<p>11.3.1 驱动电机、舵机部分</p>
</li>
<li>
<p>11.3.2 连接WiFi、发送指令部分</p>
</li>
</ul>
</li>
</ul>
<h2 id="预期学习成果-4"><a class="header" href="#预期学习成果-4">预期学习成果</a></h2>
<p>可以使用Mixly对代码进行复现，控制小车实现前进、后退、左转、右转、刹车以及机械臂的抓取、释放、复位等形态</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mixly安装与使用"><a class="header" href="#mixly安装与使用">Mixly安装与使用</a></h1>
<h2 id="mixly安装教程"><a class="header" href="#mixly安装教程">Mixly安装教程</a></h2>
<ul>
<li>官网下载
<br>https://mixly.cn/bnu-maker/mixl2.0rc
<br><img src="chapter11/../resource/img/Mixly1.jpg" alt="Mixly下载1" />
<br>跳转百度网盘后，点击Mixly2.0文件夹，显示以下文件:
<br><img src="chapter11/../resource/img/Mixly2.png" alt="Mixly下载2" />
<br>下载完之后，将文件解压，解压的目录不要有中文、空格等；安装目录不要太长，目录最好放到每个电脑盘的根目录。
打开解压后的文件夹，请双击&quot;一键更新.bat&quot;文件，按照提示安装，在此不做详细描述。等安装完成，双击“Mixly.exe”打开Mixly软件，如下图：
<br><img src="chapter11/../resource/img/Mixly3.jpg" alt="Mixly下载3" /></li>
</ul>
<h2 id="mixly使用方法"><a class="header" href="#mixly使用方法">Mixly使用方法</a></h2>
<p><br>打开界面后，找到并选择Arduino ESP32
<br><img src="chapter11/../resource/img/Mixly4.jpg" alt="Mixly使用1" />
<br>之后关注界面右上角，打开导入窗口。点击右上角”设置“按钮，选择”管理库“。如下图：
<br><img src="chapter11/../resource/img/Mixly5.jpg" alt="Mixly使用2" />
<br>https://emakefun.github.io/emakefun-docsify/#/zh-cn/esp32/maker_esp32/maker_esp32?id=mixly%e7%a4%ba%e4%be%8b%e7%a8%8b%e5%ba%8f
<br>打开以上网址，任意下载一个你感兴趣的方面，回到Mixly打开并选择你刚下的文件，就会出现文件选择框，选择 mix 后缀的文件即可
<br><img src="chapter11/../resource/img/Mixly6.png" alt="Mixly使用3" />
<br><img src="chapter11/../resource/img/Mixly7.png" alt="Mixly使用4" />
<br><img src="chapter11/../resource/img/Mixly8.png" alt="Mixly使用5" />
<br>上图以电机代码作为示例
<br>连接板子,点击上传，传到板子上即可使用</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mixly界面简单介绍"><a class="header" href="#mixly界面简单介绍">Mixly界面简单介绍</a></h1>
<h2 id="mixly界面不同分区简要介绍"><a class="header" href="#mixly界面不同分区简要介绍">Mixly界面不同分区简要介绍</a></h2>
<p><img src="chapter11/../resource/img/Mixly9.png" alt="Mixly界面" />
<br>•	<strong>基础模块区和库模块区</strong>： 同种类型的积木被分在同个模块中并赋予同种颜色，每块积木代表一条控制指令。
<br>•	<strong>功能区</strong>： 对项目文件的创建、保存，库的导入、导出、管理，串口连接与上传程序，控制板选择进行操作的区域。
<br>•	<strong>程序构建区</strong>： 是放置从基础模块区和库模块区拖拽出来的积木块的地方。
<br>•	<strong>代码区</strong>： 拖拽出积木后，点击“代码”，可以看到你拖拽的模块对应的C语言代码。
<br>•	<strong>缩放控制区</strong>： 可以将软件操作界面进行缩放。
<br>•	<strong>垃圾箱</strong>： 用来移除不需要的积木块。</p>
<h2 id="基础模块区和库模块区使用方法"><a class="header" href="#基础模块区和库模块区使用方法">基础模块区和库模块区使用方法</a></h2>
<ul>
<li>
<p><strong>一、​输入/输出</strong>​​：
<br><strong>功能</strong>​​：控制硬件引脚的电平状态或读取传感器数据。
​<br>1.<strong>​数字输入/输出</strong>​​：设置引脚为高/低电平（如控制LED开关）或读取数字信号（如按钮状态）。
​<br>2.<strong>​模拟输入/输出</strong>​​：读取模拟信号（如电位器值）或输出PWM信号（如调节LED亮度）。
​​<br>3.中断控制​​：配置硬件中断触发条件（如上升沿、下降沿）。
​<br>4.​脉冲长度​​：测量脉冲宽度（如超声波测距）
<img src="chapter11/../resource/img/Mixly10.png" alt="输入/输出" /></p>
</li>
<li>
<p><strong>二、控制​</strong>​：
<br><strong>功能​</strong>​：控制程序执行流程。
​<br>1.<strong>​初始化</strong>​​：程序启动时仅执行一次的代码块，对应Arduino的setup()函数。
​<br>2.<strong>​循环</strong>​​：重复执行的代码块，对应loop()函数。
​<br>3.<strong>​条件判断</strong>​​：如果、如果-否则模块，实现分支逻辑。
​<br>4.<strong>​循环结构</strong>​​：重复、重复直到等模块，支持计数循环和条件循环
<img src="chapter11/../resource/img/Mixly11.png" alt="控制" /></p>
</li>
<li>
<p><strong>三、数学</strong>​​：
<br><strong>功能</strong>​​：数值运算与处理。
​<br>1.<strong>​基础运算</strong>​​：加、减、乘、除、取模等。
​<br>2.​高级运算​​：三角函数、对数、幂运算、随机数生成等。
<br>3.​​数值处理​​：取整、约束范围（如map函数）、绝对值等
<img src="chapter11/../resource/img/Mixly12.png" alt="数学" /></p>
</li>
<li>
<p><strong>四、逻辑</strong>​​：
<br><strong>功能</strong>​​：逻辑判断与运算。
​<br>1.<strong>​比较运算</strong>​​：大于、等于、小于等。
​<br>2.<strong>​逻辑运算</strong>​​：与（AND）、或（OR）、非（NOT）等。
​<br>3.​三元运算符​​：?运算模块，简化条件赋值
<img src="chapter11/../resource/img/Mixly13.png" alt="逻辑" /></p>
</li>
<li>
<p><strong>五、文本与数组</strong>​​：
<br>1.<strong>文本操作</strong>​​：
字符串连接、截取、转换（如数字转文本）。
​<br>2.​数组操作​​：
定义数组、存取元素、修改长度等
<img src="chapter11/../resource/img/Mixly14.png" alt="文本" /></p>
</li>
<li>
<p><strong>六、变量与函数​</strong>​：
<br>支持整型、浮点型、布尔型等变量，以及自定义函数
<img src="chapter11/../resource/img/Mixly15.png" alt="函数" /></p>
</li>
<li>
<p><strong>七、网络WiFi</strong>
<br><strong>功能</strong>：快速实现设备接入本地Wi-Fi网络，为后续通信提供基础。
<br><strong>Wi-Fi网络连接管理​​</strong>:
​​配置连接参数​​，通过拖拽积木设置SSID和密码（设置Wi-Fi名称&quot;ssid&quot;密码&quot;password&quot;）实时监测连接状态（Wi-Fi连接事件和Wi-Fi连接状态积木）
<img src="chapter11/../resource/img/Mixly16.png" alt="网络WiFi" /></p>
</li>
<li>
<p><strong>八、自定义模块</strong>
<br><strong>功能</strong>：用户自定义代码扩展​​
​<br>1.​自由编程接口​​：允许用户突破图形化积木的限制，直接编写或嵌入原生代码，实现更复杂或个性化的功能。
<br>​2.混合编程支持​​：
图形化积木与文本代码可混合使用（例如在图形化流程中插入Serial.print打印变量值）。
​<br>3.​灵活输入输出​​：
支持变量传递（如将图形化积木中的变量名直接用于自定义代码块）。
<img src="chapter11/../resource/img/Mixly17.png" alt="自定义模块" /></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目实践mixly下代码的复现"><a class="header" href="#项目实践mixly下代码的复现">项目实践：Mixly下代码的复现</a></h1>
<h2 id="驱动电机舵机部分"><a class="header" href="#驱动电机舵机部分">驱动电机、舵机部分</a></h2>
<ul>
<li><strong>一、初始化</strong></li>
</ul>
<ul>
<li>
<p><strong>初始化串口</strong>
<br>找到Serial波特率板块，初始化为115200</p>
</li>
<li>
<p><strong>电机、舵机驱动初始化</strong>
<br>由于舵机在后续函数的编写中带有初始化，此处仅对电机做说明
<br>找到HR8833电机驱动初始化，根据管脚号分别对4组电机管脚进行初始化</p>
</li>
</ul>
<ul>
<li><strong>二、自定义函数</strong></li>
</ul>
<ul>
<li>1.<strong>控制电机具体步骤</strong>
<br>在函数部分选中无返回值、无参数自定义函数
<br>找到HR8833电机驱动设置，设置速度</li>
</ul>
<p><img src="chapter11/../resource/img/Mixly-func.png" alt="Mixly-forward" /></p>
<ul>
<li>2.<strong>控制舵机具体步骤</strong>
<br>在函数部分选中有返回值、有参数自定义函数，主要用于计算并返回duty值，控制舵机角度,示例如下：</li>
</ul>
<p><img src="chapter11/../resource/img/Mixly-setAngle.png" alt="Mixly-setAngle" /></p>
<p><br>实现对抓手运动状态控制的函数采用无返回值、无参数自定义函数，使用输入\输出部分绑定管脚赋值的图形模块</p>
<ul>
<li><strong>三、常见问题</strong></li>
</ul>
<ul>
<li>电机与舵机驱动采用不同图形模块，注意区分</li>
<li>电机部分组号要依次设置为1-4，这样可以保证PWM通道从0开始</li>
<li>舵机部分由于绑定引脚+赋值图形模块采用ledcWrite函数，因此提前自定义setAngle函数用于计算duty值，需以如下形式写入具体函数：
<img src="chapter11/../resource/img/Mixly-init.png" alt="Mixly-init" /></li>
</ul>
<h2 id="连接wifi发送指令部分"><a class="header" href="#连接wifi发送指令部分">连接WiFi、发送指令部分</a></h2>
<ul>
<li><strong>一、初始化</strong></li>
</ul>
<ul>
<li>
<p><strong>WiFi连接</strong>
<br>找到链接WiFi图形，输入需要连接的WiFi名称和密码</p>
</li>
<li>
<p>初始化代码样例
<img src="chapter11/../resource/img/Mixly-setup.png" alt="Mixly-setup" /></p>
</li>
</ul>
<ul>
<li><strong>二、发送指令部分</strong></li>
</ul>
<ul>
<li>
<p>声明变量
<br>由于后续效果是使用键盘快捷键控制小车运动，因此此处需要声明字符类型的变量key</p>
</li>
<li>
<p>TCP服务端初始化
<br>在设置-管理库-导入库中选择小绿科技-WIFI V2 Free,下载并导入
<br>选择TCP服务端初始化模块，链接名默认client</p>
</li>
<li>
<p>快捷键与函数的对应
<br>找到如果-执行模块，先判断client是否可用
<br>嵌套重复-执行模块，若符合client有链接的条件重复执行以下内容
<br>再次嵌套如果-执行模块，判断是否满足client有数据可读条件
<br>将key赋值为client中读取的单字节并打印
<br>嵌套如果-执行-否则如果执行模块，判断key是否与目标的单字节相同，若相同则执行相应函数</p>
</li>
<li>
<p>代码样例
<img src="chapter11/../resource/img/Mixly-TCP.png" alt="Mixly-TCP" /></p>
</li>
</ul>
<ul>
<li><strong>三、TCP下向服务端发送消息</strong></li>
</ul>
<ul>
<li>此处以Vscode下编写的代码为示例</li>
<li>创建一个python文件，写入以下内容：</li>
</ul>
<pre><code>import socket

# 创建socket对象
socket_client = socket.socket()
# 连接到服务器
socket_client.connect((&quot;172.16.203.162&quot;, 80))
//此处需将172.16.203.162替换为实际的IP地址

# 持续发送和接收消息
while True:
    send_msg = input(&quot;请输入要发送给服务端的消息：&quot;)
    if send_msg == &quot;exit&quot;:
        break
    socket_client.send(send_msg.encode(&quot;UTF-8&quot;))

# 关闭连接
socket_client.close()
</code></pre>
<ul>
<li><strong>四、常见问题</strong></li>
</ul>
<ul>
<li>
<p><strong>key变量定义的必要性</strong>：
<br>首先，TCP通信是流式传输，可能分多次接收数据。key作为缓冲区，暂存数据，确保每次只处理一个明确的指令字节。
​<br>​其次，全局变量key可以在不同函数或条件分支中共享，避免重复读取客户端数据（可能引发数据错位）。
​<br>若未来需要支持更多指令（如速度调节），只需扩展key的取值判断逻辑，无需重构通信部分。</p>
</li>
<li>
<p>要在如果-执行模块添加否则执行的方法与自定义函数中添加参数的方法相同，通过点击左上角设置并将模块拖拽到如果/输入中即可</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
